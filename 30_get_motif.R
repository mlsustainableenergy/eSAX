# Script to find the motifs
# MIT License
# Copyright (c) 2021 Nicole Ludwig

# load necessary libraries -----------------------------------------------------
library(EnergyMotif)
library(TSMining)
library(ggplot2)
library(foreach)
library(RColorBrewer)
library(e1071)
library(plyr)
library(readxl)

# set proper working directory and load the data to be analysed ----------------

ts.subs <- NULL
aggregation <- c("1 second", "2 min", "10 min", "2 hours")

for (a in aggregation) {
  print(paste("Looking at ", a, "data aggregation"))

  load(paste0("data/ecdf_", a, ".RData"))

  load(paste0("data/tssubs_", a, ".RData")) # data generated by "20_get_subsequences.R"

  # Set parameters for the eSAX algorithm
  breaks      <- 10 # number of breakpoints for the eSAX algorithm
  w           <- median(unlist(lapply(ts.subs, length))) # word size

  # Set parameters for the random projection.
  iter      <- min(round(max(unlist(lapply(ts.subs, length))) * 0.1), w/10)
  mask.size <- 2

  # Set parameters for the motif discovery.
  max.dist.ratio <- 2.5
  count.ratio.1  <- 5
  count.ratio.2  <- 1.5

  # Calculate the breakpoints for the eSAX algorithm
  # set the number of breakpoints (percentiles)
  qq <- seq(0, 1, 1/breaks)

  # store the percentiles
  per <- as.numeric(stats::quantile(my.ecdf, qq))

  # use only unique percentiles for the alphabet distribution
  per <- unique(per)

  # add the minimum as the lowest letter
  per[1] <- min(unlist(lapply(ts.subs, min)))

  # Create the eSAX time series ------------------------------------------------

  print("Creating the eSAX pieces")
  # Create list to access the SAX pieces later.
  pieces.all <- list()

  # initialize an empty vector for the result
  ts.sax <- vector("list", length(ts.subs) + 1)

  # Transformation of every subsequence in ts.subs into a symbolic aggregation.
  ts.sax <- foreach::foreach(i = 1:length(ts.subs), .combine = rbind) %do% {

    sax.temp <- create.eSAX(x = ts.subs[[i]], w = w, b = per)

    # Store the startpoint of each sequence in the original time series,
    # the startpoint is the sum of the length of all previous sequences + 1
    # for the first sequence there are no previous sequences, thus start = 1.
    startpoints <- ifelse(i > 1,
                          sum(unlist(lapply(ts.subs[1:(i - 1)], length))) + 1,
                          1)

    # store the sax pieces.
    pieces <- sax.temp[["pieces"]]
    pieces.all[[i]] <- pieces

    return(c(startpoints, sax.temp[["sym"]]))
  }

  # Get ts.sax into a nice data frame (= sequence matrix).
  ts.sax           <- as.data.frame(ts.sax, stringsAsFactors = FALSE)
  colnames(ts.sax) <- c("StartP", 1:w)
  ts.sax$StartP    <- as.numeric(ts.sax$StartP)


  # Search for motifs using the eSAX representation of the time series ---------

  print("Searching for Motifs")
  # Perform the random projection
  col.mat <- matrix(data = 0, nrow = dim(ts.sax)[1], ncol = dim(ts.sax)[1])

  for (i in 1:iter) {
    set.seed(i + 42)
    col.pos <- sort(sample(x = 2:dim(ts.sax)[2], size = mask.size, replace = FALSE),
                    decreasing = FALSE)

    sax.mask <- ts.sax[,col.pos]

    unique.lab <- unique(sax.mask)

    mat <- foreach::foreach(j = 1:dim(unique.lab)[1], .combine = rbind) %do% {
      indices <- foreach::foreach(q = 1:dim(sax.mask)[1], .combine = c) %do% {
        identical(as.character(sax.mask[q,]), as.character(unique.lab[j,]))
      }
    }

    if (length(dim(mat)) == 0) {
      for (m in 1:length(mat)) {
        if (length(which(mat == TRUE)) > 1) {
          com <- t(utils::combn(x = which(mat == TRUE), m = 2))
          col.mat[com] <- col.mat[com] + 1
        }
      }
    } else {
      for (m in 1:dim(mat)[1]) {
        if (length(which(mat[m,] == TRUE)) > 1) {
          com <- t(utils::combn(x = which(mat[m,] == TRUE), m = 2))
          col.mat[com] <- col.mat[com] + 1
        }
      }
    }
  }

  # Extract the tentative motif pair
  counts     <- sort(col.mat, decreasing = TRUE)
  counts.sel <- counts[which(counts >= (iter/count.ratio.1))]

  motif.pair <- foreach(k = 1:length(unique(counts.sel)), .combine = rbind) %do% {
    arrayInd(which(col.mat == unique(counts.sel)[k]), .dim = dim(col.mat))
  }

  indices <- foreach(l = 1:dim(motif.pair)[1]) %do% {

    pair   <- c(ts.sax[motif.pair[l,1],1], ts.sax[motif.pair[l,2],1])
    cand.1 <- ts.subs[[motif.pair[l,1]]]
    cand.2 <- ts.subs[[motif.pair[l,2]]]

    dist.raw <- sqrt(sum((cand.1 - cand.2)^2))

    col.no   <- col.mat[motif.pair[l,1],]

    ind.cand <- which(col.no > (max(col.no)/count.ratio.2))

    if (length(ind.cand) > 1) {

      ind.temp <- ind.cand[-which(ind.cand == motif.pair[l,2])]

      if (length(ind.temp) == 1) {
        df.cand.sel <- as.matrix(ts.subs[[ind.temp]])
        dist.res <- plyr::aaply(.data = df.cand.sel,
                                .margins = 2,
                                .fun = function(x) sqrt(sum((cand.1 - x)^2)))

        ind.final <- ts.sax[ind.temp[which(dist.res <= max.dist.ratio*dist.raw)],1]
      } else {

        df.cand.sel <- ts.subs[ind.temp]

        dist.res    <- plyr::aaply(.data = df.cand.sel,
                                   .margins = 1,
                                   .fun = function(x) sqrt(sum((cand.1 - x)^2)))

        ind.final <- ts.sax[ind.temp[which(dist.res <= max.dist.ratio*dist.raw)],1]
      }

    } else {
      ind.final <- NULL
    }
    pair.final <- c(pair, ind.final)
  }

  #Combine the indices if there is any overlap
  vec.subset <- rep(0, length(indices))
  foreach::foreach(g = 1:(length(indices) - 1), .combine = rbind) %do% {
    for (h in (g + 1):length(indices)) {
      if (length(which(indices[[g]] %in% indices[[h]])) > 0) {
        indices[[h]] <- unique(c(indices[[g]], indices[[h]]))
        vec.subset[g] <- 1
      }
    }
  }

  indices <- indices[vec.subset == 0]

  motif.raw <- foreach::foreach(u = 1:length(indices)) %do% {
    ts.subs[which(ts.sax[,1] %in% indices[[u]])]
  }

  motif.sax <- foreach::foreach(u = 1:length(indices)) %do% {
    ts.sax[which(ts.sax[,1] %in% indices[[u]]),]
  }

  found.motifs <- list(Subs             = ts.subs,
                       Subs.SAX         = ts.sax,
                       Motif.raw        = motif.raw,
                       Motif.SAX        = motif.sax,
                       Collision.matrix = col.mat,
                       Indices          = indices,
                       pieces           = pieces.all)

  save(found.motifs, file = paste0("data/motifs_", a, ".RData"))

  print("Done")
}

print("All Motifs searched ... ")

rm(list = ls())
